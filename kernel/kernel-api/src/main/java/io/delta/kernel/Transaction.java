/*
 * Copyright (2023) The Delta Lake Project Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.delta.kernel;

import java.util.List;
import java.util.Map;

import io.delta.kernel.annotation.Evolving;
import io.delta.kernel.client.TableClient;
import io.delta.kernel.data.FilteredColumnarBatch;
import io.delta.kernel.data.Row;
import io.delta.kernel.expressions.Literal;
import io.delta.kernel.types.StructType;
import io.delta.kernel.utils.CloseableIterator;
import io.delta.kernel.utils.DataFileStatus;

import io.delta.kernel.internal.lang.CloseableIterable;

/**
 * Represents a transaction to mutate a Delta table.
 *
 * @since 3.2.0
 */
@Evolving
public interface Transaction {
    /**
     * Get the expected output of the data that is being written to the table.
     */
    StructType getSchema(TableClient tableClient);

    /**
     * Get the list of logical names of the partition columns. This helps the connector to do
     * physical partitioning of the data before asking the Kernel to stage the data per partition.
     */
    List<String> getPartitionColumns(TableClient tableClient);

    /**
     * Get the state of the transaction.
     */
    Row getState(TableClient tableClient);

    /**
     * Commit the transaction including the staged data rows generated by either or both
     * `Transaction.stageAppendOnlyData` or `Transaction.stageMergeData`.
     *
     * @param tableClient    {@link TableClient} instance.
     * @param stagedData     Iterator of data actions to commit. These data actions are generated by
     *                       the `Transaction.stageAppendOnlyData` or manually created. Manual
     *                       creation of data actions is useful when has the data files and want to
     *                       directly inject them into the table. One important note is that the
     *                       connector should be able to provide the same content if the transaction
     *                       commit fails and needs to be retried.
     * @param maximumRetries If the transaction is retried, return the previous status of the
     *                       transaction. This helps the Kernel reuse the conflict resolution work
     *                       done in the previous attempt.
     * @return {@link TransactionCommitStatus} status of the successful transaction.
     * @throws ConcurrentWriteException when the transaction has encountered a non-retryable
     *                                  conflicts or exceeded the maximum number of retries reached.
     *                                  The connector needs to rerun the query on top of the latest
     *                                  table state and retry the transaction.
     */
    TransactionCommitStatus commitWithRetries(
            TableClient tableClient,
            CloseableIterable<Row> stagedData,
            int maximumRetries
    ) throws ConcurrentWriteException;

    /**
     * Given the logical data that needs to be written to the table, convert it into the required
     * physical data depending upon the table Delta protocol and features enabled on the table.
     * Kernel takes care of adding any additional column or removing existing columns that doesn't
     * need to be in physical data files. All these transformations are driven by the Delta protocol
     * and table features enabled on the table.
     * <p>
     * The given data should belong to exactly one partition. It is the job the connector to do
     * partitioning of the data before calling the API. Partition values are provided as map of
     * column name to partition value (as {@link Literal}). If the table is an un-partitioned table,
     * then map should be empty.
     *
     * @param tableClient      {@link TableClient} instance to use.
     * @param transactionState The transaction state
     * @param dataIter         Iterator of logical data to transform to physical data. All the data
     *                         in this iterator should belong to one physical partition.
     * @param partitionValues  The partition values for the data. If the table is un-partitioned,
     *                         the map should be empty
     * @return Iterator of physical data to write to the data files.
     */
    static CloseableIterator<FilteredColumnarBatch> transformLogicalData(
            TableClient tableClient,
            Row transactionState,
            CloseableIterator<FilteredColumnarBatch> dataIter,
            Map<String, Literal> partitionValues) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    /**
     * Get the context for writing data into a table. The context tells the connector where the data
     * should be written and what should be the target file size.
     *
     * @param tableClient      {@link TableClient} instance to use.
     * @param transactionState
     * @param partitionValues
     * @return
     */
    static DataWriteContext getWriteContext(
            TableClient tableClient,
            Row transactionState,
            Map<String, Literal> partitionValues) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    /**
     * Stage the given data files as a Delta actions that can be committed in a transaction.
     *
     * @param tableClient      {@link TableClient} instance.
     * @param transactionState State of the transaction.
     * @param fileStatusIter   Iterator of row objects representing each data file written.
     * @param dataWriteContext The context used when writing the data files given in
     *                         {@code fileStatusIter}
     * @return
     */
    static CloseableIterator<Row> stageAppendOnlyData(
            TableClient tableClient,
            Row transactionState,
            CloseableIterator<DataFileStatus> fileStatusIter,
            DataWriteContext dataWriteContext) {
        throw new UnsupportedOperationException("Not yet implemented");
    }
}
